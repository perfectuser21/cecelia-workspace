---
id: tick-cecelia-integration
version: 1.0.0
created: 2026-01-31
updated: 2026-01-31
changelog:
  - 1.0.0: 初始版本
---

# PRD: Tick + cecelia-run 集成（自驱系统阶段 1）

## 背景

当前 Brain API 的 `/api/brain/tick` 只能改变任务状态（queued → in_progress），但不会触发实际执行。我们需要让 tick 能够触发 cecelia-run 无头执行，实现最小闭环的自驱系统。

## 目标

让 tick 机制能够：
1. 检测到 queued 任务时，触发 cecelia-run 执行
2. cecelia-run 完成后，通过 webhook 回调更新任务状态
3. 形成完整的 tick → 执行 → 回调 → 下一个 tick 循环

## 功能需求

### 1. Tick 触发执行

修改 `tick.js` 的 `executeTick()` 函数：

```javascript
// 当前：只改状态
await updateTask({ task_id: nextTask.id, status: 'in_progress' });

// 改为：改状态 + 触发执行
await updateTask({ task_id: nextTask.id, status: 'in_progress' });
await triggerCeceliaRun(nextTask);
```

### 2. triggerCeceliaRun 函数

新增函数，负责：
- 从 task 获取 prd_content 或 prd_path
- 生成临时 prompt 文件
- 调用 cecelia-run（异步，不等待）
- 记录执行 ID

```javascript
async function triggerCeceliaRun(task) {
  // 1. 准备 prompt
  const promptContent = task.prd_content || `/dev ${task.prd_path}`;
  const promptFile = `/tmp/cecelia-prompt-${task.id}.txt`;
  await fs.writeFile(promptFile, promptContent);

  // 2. 生成执行 ID
  const runId = `run-${task.id}-${Date.now()}`;

  // 3. 异步调用 cecelia-run
  const cmd = `nohup cecelia-run "${task.id}" "${runId}" "${promptFile}" > /tmp/cecelia-${task.id}.log 2>&1 &`;
  exec(cmd);

  // 4. 记录到 task
  await updateTaskRunId(task.id, runId);

  return { runId, taskId: task.id };
}
```

### 3. 执行完成回调

新增 webhook 端点 `POST /api/brain/execution-callback`：

```javascript
router.post('/execution-callback', async (req, res) => {
  const { task_id, run_id, status, result, pr_url, duration_ms } = req.body;

  // 1. 验证 run_id 匹配
  // 2. 更新任务状态
  if (status === 'AI Done') {
    await updateTask({ task_id, status: 'completed' });
    if (pr_url) {
      await updateTaskPrUrl(task_id, pr_url);
    }
  } else if (status === 'AI Failed') {
    await updateTask({ task_id, status: 'failed' });
  }

  // 3. 记录决策日志
  await logExecutionResult(task_id, run_id, status, result, duration_ms);

  res.json({ success: true });
});
```

### 4. 修改 cecelia-run webhook 配置

确保 cecelia-run 的 `WEBHOOK_URL` 指向新端点：

```bash
WEBHOOK_URL="http://localhost:5212/api/brain/execution-callback"
```

## 数据模型变更

### tasks 表新增字段

```sql
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS current_run_id TEXT;
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS pr_url TEXT;
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS last_run_result JSONB;
```

## 验收标准

### AC1: Tick 触发执行
- [ ] 创建一个 queued 状态的 task（带 prd_content）
- [ ] 调用 `POST /api/brain/tick`
- [ ] task 状态变为 in_progress
- [ ] cecelia-run 进程启动
- [ ] `/tmp/cecelia-{task_id}.log` 有输出

### AC2: 回调更新状态
- [ ] cecelia-run 完成后自动调用 webhook
- [ ] task 状态变为 completed 或 failed
- [ ] pr_url 字段被更新（如果有）
- [ ] decision_log 有执行记录

### AC3: 连续执行
- [ ] 创建 3 个 queued tasks
- [ ] 调用多次 tick
- [ ] 第一个完成后，第二个自动开始
- [ ] 最终 3 个都 completed

## 技术约束

1. **异步执行**：cecelia-run 必须异步调用，tick 不等待完成
2. **幂等性**：重复 tick 不会重复触发已 in_progress 的任务
3. **并发控制**：遵守 MAX_CONCURRENT=8 的限制
4. **错误处理**：cecelia-run 启动失败时，task 状态回滚

## 文件变更清单

| 文件 | 变更类型 | 说明 |
|------|----------|------|
| `apps/core/src/brain/tick.js` | 修改 | 添加 triggerCeceliaRun 调用 |
| `apps/core/src/brain/routes.js` | 修改 | 添加 execution-callback 端点 |
| `apps/core/src/brain/executor.js` | 新增 | cecelia-run 触发逻辑 |
| `migrations/xxx_add_task_run_fields.sql` | 新增 | 数据库迁移 |

## 风险

1. **cecelia-run 路径**：确保 Core 容器能访问 cecelia-run
2. **权限**：Core 进程需要有执行权限
3. **日志**：确保日志目录存在且可写

## 后续阶段

- 阶段 2：TRD 分解器
- 阶段 3：目标对比 + 迭代决策
- 阶段 4：完整自驱循环
