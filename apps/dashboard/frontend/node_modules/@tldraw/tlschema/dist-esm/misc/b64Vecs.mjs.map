{
  "version": 3,
  "sources": ["../../src/misc/b64Vecs.ts"],
  "sourcesContent": ["import { assert } from '@tldraw/utils'\nimport { VecModel } from './geometry-types'\n\n// Each point = 3 Float16s = 6 bytes = 8 base64 chars (legacy format)\nconst _POINT_B64_LENGTH = 8\n\n// First point in delta encoding = 3 Float32s = 12 bytes = 16 base64 chars\nconst FIRST_POINT_B64_LENGTH = 16\n\n// O(1) lookup table for base64 decoding (maps char code -> 6-bit value)\nconst BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nconst B64_LOOKUP = new Uint8Array(128)\nfor (let i = 0; i < 64; i++) {\n\tB64_LOOKUP[BASE64_CHARS.charCodeAt(i)] = i\n}\n\n// Precomputed powers of 2 for Float16 exponents (exp - 15, so indices 0-30 map to 2^-15 to 2^15)\nconst POW2 = new Float64Array(31)\nfor (let i = 0; i < 31; i++) {\n\tPOW2[i] = Math.pow(2, i - 15)\n}\nconst POW2_SUBNORMAL = Math.pow(2, -14) / 1024 // For subnormal numbers\n\n// Precomputed mantissa values: 1 + frac/1024 for all 1024 possible frac values\n// Avoids division in hot path\nconst MANTISSA = new Float64Array(1024)\nfor (let i = 0; i < 1024; i++) {\n\tMANTISSA[i] = 1 + i / 1024\n}\n\ndeclare global {\n\tinterface Uint8Array {\n\t\ttoBase64?(): string\n\t}\n\tinterface Uint8ArrayConstructor {\n\t\tfromBase64?(base64: string): Uint8Array\n\t}\n}\n\nfunction nativeGetFloat16(dataView: DataView, offset: number): number {\n\treturn (dataView as any).getFloat16(offset, true)\n}\nfunction fallbackGetFloat16(dataView: DataView, offset: number): number {\n\treturn float16BitsToNumber(dataView.getUint16(offset, true))\n}\n\nconst getFloat16 =\n\ttypeof (DataView.prototype as any).getFloat16 === 'function'\n\t\t? nativeGetFloat16\n\t\t: fallbackGetFloat16\n\nfunction nativeSetFloat16(dataView: DataView, offset: number, value: number): void {\n\t;(dataView as any).setFloat16(offset, value, true)\n}\nfunction fallbackSetFloat16(dataView: DataView, offset: number, value: number): void {\n\tdataView.setUint16(offset, numberToFloat16Bits(value), true)\n}\n\nconst setFloat16 =\n\ttypeof (DataView.prototype as any).setFloat16 === 'function'\n\t\t? nativeSetFloat16\n\t\t: fallbackSetFloat16\n\nfunction nativeBase64ToUint8Array(base64: string): Uint8Array {\n\treturn Uint8Array.fromBase64!(base64)\n}\n\n/** @internal */\nexport function fallbackBase64ToUint8Array(base64: string): Uint8Array {\n\tconst numBytes = Math.floor((base64.length * 3) / 4)\n\tconst bytes = new Uint8Array(numBytes)\n\tlet byteIndex = 0\n\n\tfor (let i = 0; i < base64.length; i += 4) {\n\t\tconst c0 = B64_LOOKUP[base64.charCodeAt(i)]\n\t\tconst c1 = B64_LOOKUP[base64.charCodeAt(i + 1)]\n\t\tconst c2 = B64_LOOKUP[base64.charCodeAt(i + 2)]\n\t\tconst c3 = B64_LOOKUP[base64.charCodeAt(i + 3)]\n\n\t\tconst bitmap = (c0 << 18) | (c1 << 12) | (c2 << 6) | c3\n\n\t\tbytes[byteIndex++] = (bitmap >> 16) & 255\n\t\tbytes[byteIndex++] = (bitmap >> 8) & 255\n\t\tbytes[byteIndex++] = bitmap & 255\n\t}\n\n\treturn bytes\n}\n\nfunction nativeUint8ArrayToBase64(uint8Array: Uint8Array): string {\n\treturn uint8Array.toBase64!()\n}\n\n/** @internal */\nexport function fallbackUint8ArrayToBase64(uint8Array: Uint8Array): string {\n\tassert(uint8Array.length % 3 === 0, 'Uint8Array length must be a multiple of 3')\n\tlet result = ''\n\n\t// Process bytes in groups of 3 -> 4 base64 chars\n\tfor (let i = 0; i < uint8Array.length; i += 3) {\n\t\tconst byte1 = uint8Array[i]\n\t\tconst byte2 = uint8Array[i + 1]\n\t\tconst byte3 = uint8Array[i + 2]\n\n\t\tconst bitmap = (byte1 << 16) | (byte2 << 8) | byte3\n\t\tresult +=\n\t\t\tBASE64_CHARS[(bitmap >> 18) & 63] +\n\t\t\tBASE64_CHARS[(bitmap >> 12) & 63] +\n\t\t\tBASE64_CHARS[(bitmap >> 6) & 63] +\n\t\t\tBASE64_CHARS[bitmap & 63]\n\t}\n\n\treturn result\n}\n\n/**\n * Convert a Uint8Array to base64.\n * Processes bytes in groups of 3 to produce 4 base64 characters.\n *\n * @internal\n */\nconst uint8ArrayToBase64 =\n\ttypeof Uint8Array.prototype.toBase64 === 'function'\n\t\t? nativeUint8ArrayToBase64\n\t\t: fallbackUint8ArrayToBase64\n\n/**\n * Convert a base64 string to Uint8Array.\n *\n * @internal\n */\nconst base64ToUint8Array =\n\ttypeof Uint8Array.fromBase64 === 'function'\n\t\t? nativeBase64ToUint8Array\n\t\t: fallbackBase64ToUint8Array\n\n/**\n * Convert Float16 bits to a number using optimized lookup tables.\n * Handles normal numbers, subnormal numbers, zero, infinity, and NaN.\n *\n * @param bits - The 16-bit Float16 value to decode\n * @returns The decoded number value\n * @internal\n */\nexport function float16BitsToNumber(bits: number): number {\n\tconst sign = bits >> 15\n\tconst exp = (bits >> 10) & 0x1f\n\tconst frac = bits & 0x3ff\n\n\tif (exp === 0) {\n\t\t// Subnormal or zero - rare case\n\t\treturn sign ? -frac * POW2_SUBNORMAL : frac * POW2_SUBNORMAL\n\t}\n\tif (exp === 31) {\n\t\t// Infinity or NaN - very rare\n\t\treturn frac ? NaN : sign ? -Infinity : Infinity\n\t}\n\t// Normal case - two table lookups, one multiply, no division\n\tconst magnitude = POW2[exp] * MANTISSA[frac]\n\treturn sign ? -magnitude : magnitude\n}\n\n/**\n * Convert a number to Float16 bits.\n * Handles normal numbers, subnormal numbers, zero, infinity, and NaN.\n *\n * @param value - The number to encode as Float16\n * @returns The 16-bit Float16 representation of the number\n * @internal\n */\nexport function numberToFloat16Bits(value: number): number {\n\tif (value === 0) return Object.is(value, -0) ? 0x8000 : 0\n\tif (!Number.isFinite(value)) {\n\t\tif (Number.isNaN(value)) return 0x7e00\n\t\treturn value > 0 ? 0x7c00 : 0xfc00\n\t}\n\n\tconst sign = value < 0 ? 1 : 0\n\tvalue = Math.abs(value)\n\n\t// Find exponent and mantissa\n\tconst exp = Math.floor(Math.log2(value))\n\tlet expBiased = exp + 15\n\n\tif (expBiased >= 31) {\n\t\t// Overflow to infinity\n\t\treturn (sign << 15) | 0x7c00\n\t}\n\tif (expBiased <= 0) {\n\t\t// Subnormal or underflow\n\t\tconst frac = Math.round(value * Math.pow(2, 14) * 1024)\n\t\treturn (sign << 15) | (frac & 0x3ff)\n\t}\n\n\t// Normal number\n\tconst mantissa = value / Math.pow(2, exp) - 1\n\tlet frac = Math.round(mantissa * 1024)\n\n\t// Handle rounding overflow: if frac rounds to 1024, increment exponent\n\tif (frac >= 1024) {\n\t\tfrac = 0\n\t\texpBiased++\n\t\tif (expBiased >= 31) {\n\t\t\t// Overflow to infinity\n\t\t\treturn (sign << 15) | 0x7c00\n\t\t}\n\t}\n\n\treturn (sign << 15) | (expBiased << 10) | frac\n}\n\n/**\n * Utilities for encoding and decoding points using base64 and Float16 encoding.\n * Provides functions for converting between VecModel arrays and compact base64 strings,\n * as well as individual point encoding/decoding operations.\n *\n * @public\n */\nexport class b64Vecs {\n\t/**\n\t * Encode a single point (x, y, z) to 8 base64 characters using legacy Float16 encoding.\n\t * Each coordinate is encoded as a Float16 value, resulting in 6 bytes total.\n\t *\n\t * @param x - The x coordinate\n\t * @param y - The y coordinate\n\t * @param z - The z coordinate\n\t * @returns An 8-character base64 string representing the point\n\t * @internal\n\t */\n\tstatic _legacyEncodePoint(x: number, y: number, z: number): string {\n\t\tconst buffer = new Uint8Array(6)\n\t\tconst dataView = new DataView(buffer.buffer)\n\n\t\tsetFloat16(dataView, 0, x)\n\t\tsetFloat16(dataView, 2, y)\n\t\tsetFloat16(dataView, 4, z)\n\n\t\treturn uint8ArrayToBase64(buffer)\n\t}\n\n\t/**\n\t * Convert an array of VecModels to a base64 string using legacy Float16 encoding.\n\t * Uses Float16 encoding for each coordinate (x, y, z). If a point's z value is\n\t * undefined, it defaults to 0.5.\n\t *\n\t * @param points - An array of VecModel objects to encode\n\t * @returns A base64-encoded string containing all points\n\t * @internal Used only for migrations from legacy format\n\t */\n\tstatic _legacyEncodePoints(points: VecModel[]): string {\n\t\tif (points.length === 0) return ''\n\n\t\t// 3 Float16s per point = 6 bytes per point\n\t\tconst buffer = new Uint8Array(points.length * 6)\n\t\tconst dataView = new DataView(buffer.buffer)\n\n\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\tconst p = points[i]\n\t\t\tconst offset = i * 6\n\t\t\tsetFloat16(dataView, offset, p.x)\n\t\t\tsetFloat16(dataView, offset + 2, p.y)\n\t\t\tsetFloat16(dataView, offset + 4, p.z ?? 0.5)\n\t\t}\n\n\t\treturn uint8ArrayToBase64(buffer)\n\t}\n\n\t/**\n\t * Convert a legacy base64 string back to an array of VecModels.\n\t * Decodes Float16-encoded coordinates (x, y, z) from the base64 string.\n\t *\n\t * @param base64 - The base64-encoded string containing point data\n\t * @returns An array of VecModel objects decoded from the string\n\t * @internal Used only for migrations from legacy format\n\t */\n\tstatic _legacyDecodePoints(base64: string): VecModel[] {\n\t\tconst bytes = base64ToUint8Array(base64)\n\t\tconst dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n\t\tconst result: VecModel[] = []\n\t\tfor (let offset = 0; offset < bytes.length; offset += 6) {\n\t\t\tresult.push({\n\t\t\t\tx: getFloat16(dataView, offset),\n\t\t\t\ty: getFloat16(dataView, offset + 2),\n\t\t\t\tz: getFloat16(dataView, offset + 4),\n\t\t\t})\n\t\t}\n\t\treturn result\n\t}\n\n\t/**\n\t * Encode an array of VecModels using delta encoding for improved precision.\n\t * The first point is stored as Float32 (high precision for absolute position),\n\t * subsequent points are stored as Float16 deltas from the previous point.\n\t * This provides full precision for the starting position and excellent precision\n\t * for deltas between consecutive points (which are typically small values).\n\t *\n\t * Format:\n\t * - First point: 3 Float32 values = 12 bytes = 16 base64 chars\n\t * - Delta points: 3 Float16 values each = 6 bytes = 8 base64 chars each\n\t *\n\t * @param points - An array of VecModel objects to encode\n\t * @returns A base64-encoded string containing delta-encoded points\n\t * @public\n\t */\n\tstatic encodePoints(points: VecModel[]): string {\n\t\tif (points.length === 0) return ''\n\n\t\t// First point: 3 Float32s = 12 bytes\n\t\t// Remaining points: 3 Float16s each = 6 bytes each\n\t\tconst firstPointBytes = 12\n\t\tconst deltaBytes = (points.length - 1) * 6\n\t\tconst totalBytes = firstPointBytes + deltaBytes\n\n\t\tconst buffer = new Uint8Array(totalBytes)\n\t\tconst dataView = new DataView(buffer.buffer)\n\n\t\t// First point is stored as Float32 for full precision\n\t\tconst first = points[0]\n\t\tdataView.setFloat32(0, first.x, true) // little-endian\n\t\tdataView.setFloat32(4, first.y, true)\n\t\tdataView.setFloat32(8, first.z ?? 0.5, true)\n\n\t\t// Subsequent points are Float16 deltas from the previous point\n\t\tlet prevX = first.x\n\t\tlet prevY = first.y\n\t\tlet prevZ = first.z ?? 0.5\n\n\t\tfor (let i = 1; i < points.length; i++) {\n\t\t\tconst p = points[i]\n\t\t\tconst z = p.z ?? 0.5\n\n\t\t\tconst offset = firstPointBytes + (i - 1) * 6\n\t\t\tsetFloat16(dataView, offset, p.x - prevX)\n\t\t\tsetFloat16(dataView, offset + 2, p.y - prevY)\n\t\t\tsetFloat16(dataView, offset + 4, z - prevZ)\n\n\t\t\tprevX = p.x\n\t\t\tprevY = p.y\n\t\t\tprevZ = z\n\t\t}\n\n\t\treturn uint8ArrayToBase64(buffer)\n\t}\n\n\t/**\n\t * Decode a delta-encoded base64 string back to an array of absolute VecModels.\n\t * The first point is stored as Float32 (high precision), subsequent points are\n\t * Float16 deltas that are accumulated to reconstruct absolute positions.\n\t *\n\t * @param base64 - The base64-encoded string containing delta-encoded point data\n\t * @returns An array of VecModel objects with absolute coordinates\n\t * @public\n\t */\n\tstatic decodePoints(base64: string): VecModel[] {\n\t\tif (base64.length === 0) return []\n\n\t\tconst bytes = base64ToUint8Array(base64)\n\t\tconst dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n\t\tconst result: VecModel[] = []\n\n\t\t// First point is Float32 (12 bytes)\n\t\tlet x = dataView.getFloat32(0, true)\n\t\tlet y = dataView.getFloat32(4, true)\n\t\tlet z = dataView.getFloat32(8, true)\n\t\tresult.push({ x, y, z })\n\n\t\t// Subsequent points are Float16 deltas - accumulate to get absolute positions\n\t\tconst firstPointBytes = 12\n\t\tfor (let offset = firstPointBytes; offset < bytes.length; offset += 6) {\n\t\t\tx += getFloat16(dataView, offset)\n\t\t\ty += getFloat16(dataView, offset + 2)\n\t\t\tz += getFloat16(dataView, offset + 4)\n\t\t\tresult.push({ x, y, z })\n\t\t}\n\n\t\treturn result\n\t}\n\n\t/**\n\t * Get the first point from a delta-encoded base64 string.\n\t * The first point is stored as Float32 for full precision.\n\t *\n\t * @param b64Points - The delta-encoded base64 string\n\t * @returns The first point as a VecModel, or null if the string is too short\n\t * @public\n\t */\n\tstatic decodeFirstPoint(b64Points: string): VecModel | null {\n\t\t// First point needs 16 base64 chars (12 bytes as Float32)\n\t\tif (b64Points.length < FIRST_POINT_B64_LENGTH) return null\n\n\t\tconst bytes = base64ToUint8Array(b64Points.slice(0, FIRST_POINT_B64_LENGTH))\n\t\tconst dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n\n\t\treturn {\n\t\t\tx: dataView.getFloat32(0, true),\n\t\t\ty: dataView.getFloat32(4, true),\n\t\t\tz: dataView.getFloat32(8, true),\n\t\t}\n\t}\n\n\t/**\n\t * Get the last point from a delta-encoded base64 string.\n\t * Requires decoding all points to accumulate deltas.\n\t *\n\t * @param b64Points - The delta-encoded base64 string\n\t * @returns The last point as a VecModel, or null if the string is too short\n\t * @public\n\t */\n\tstatic decodeLastPoint(b64Points: string): VecModel | null {\n\t\tif (b64Points.length < FIRST_POINT_B64_LENGTH) return null\n\n\t\tconst bytes = base64ToUint8Array(b64Points)\n\t\tconst dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n\n\t\t// Start with first point (Float32)\n\t\tlet x = dataView.getFloat32(0, true)\n\t\tlet y = dataView.getFloat32(4, true)\n\t\tlet z = dataView.getFloat32(8, true)\n\n\t\t// Accumulate all Float16 deltas to get the last point\n\t\tconst firstPointBytes = 12\n\t\tfor (let offset = firstPointBytes; offset < bytes.length; offset += 6) {\n\t\t\tx += getFloat16(dataView, offset)\n\t\t\ty += getFloat16(dataView, offset + 2)\n\t\t\tz += getFloat16(dataView, offset + 4)\n\t\t}\n\n\t\treturn { x, y, z }\n\t}\n}\n"],
  "mappings": "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",
  "names": ["frac"]
}
