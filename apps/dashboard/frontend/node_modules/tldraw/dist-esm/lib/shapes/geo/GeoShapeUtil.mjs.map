{
  "version": 3,
  "sources": ["../../../../src/lib/shapes/geo/GeoShapeUtil.tsx"],
  "sourcesContent": ["/* eslint-disable react-hooks/rules-of-hooks */\nimport {\n\tBaseBoxShapeUtil,\n\tBox,\n\tEMPTY_ARRAY,\n\tEditor,\n\tGroup2d,\n\tHTMLContainer,\n\tHandleSnapGeometry,\n\tRectangle2d,\n\tSVGContainer,\n\tSvgExportContext,\n\tTLGeoShape,\n\tTLGeoShapeProps,\n\tTLResizeInfo,\n\tTLShapeUtilCanvasSvgDef,\n\tVec,\n\tWeakCache,\n\texhaustiveSwitchError,\n\tgeoShapeMigrations,\n\tgeoShapeProps,\n\tgetColorValue,\n\tgetDefaultColorTheme,\n\tgetFontsFromRichText,\n\tisEqual,\n\tlerp,\n\ttoRichText,\n\tuseValue,\n} from '@tldraw/editor'\nimport {\n\tisEmptyRichText,\n\trenderHtmlFromRichTextForMeasurement,\n\trenderPlaintextFromRichText,\n} from '../../utils/text/richText'\nimport { HyperlinkButton } from '../shared/HyperlinkButton'\nimport { RichTextLabel, RichTextSVG } from '../shared/RichTextLabel'\nimport {\n\tFONT_FAMILIES,\n\tLABEL_FONT_SIZES,\n\tLABEL_PADDING,\n\tSTROKE_SIZES,\n\tTEXT_PROPS,\n} from '../shared/default-shape-constants'\nimport { getFillDefForCanvas, getFillDefForExport } from '../shared/defaultStyleDefs'\nimport { useDefaultColorTheme } from '../shared/useDefaultColorTheme'\nimport { useIsReadyForEditing } from '../shared/useEditablePlainText'\nimport { useEfficientZoomThreshold } from '../shared/useEfficientZoomThreshold'\nimport { GeoShapeBody } from './components/GeoShapeBody'\nimport { getGeoShapePath } from './getGeoShapePath'\n\nconst MIN_SIZE_WITH_LABEL = 17 * 3\n\n/** @public */\nexport class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {\n\tstatic override type = 'geo' as const\n\tstatic override props = geoShapeProps\n\tstatic override migrations = geoShapeMigrations\n\n\toverride options = {\n\t\tshowTextOutline: true,\n\t}\n\n\toverride canEdit() {\n\t\treturn true\n\t}\n\n\toverride getDefaultProps(): TLGeoShape['props'] {\n\t\treturn {\n\t\t\tw: 100,\n\t\t\th: 100,\n\t\t\tgeo: 'rectangle',\n\t\t\tdash: 'draw',\n\t\t\tgrowY: 0,\n\t\t\turl: '',\n\t\t\tscale: 1,\n\n\t\t\t// Text properties\n\t\t\tcolor: 'black',\n\t\t\tlabelColor: 'black',\n\t\t\tfill: 'none',\n\t\t\tsize: 'm',\n\t\t\tfont: 'draw',\n\t\t\talign: 'middle',\n\t\t\tverticalAlign: 'middle',\n\t\t\trichText: toRichText(''),\n\t\t}\n\t}\n\n\toverride getGeometry(shape: TLGeoShape) {\n\t\tconst { props } = shape\n\t\tconst { scale } = props\n\t\tconst path = getGeoShapePath(shape)\n\t\tconst pathGeometry = path.toGeometry()\n\n\t\tconst scaledW = Math.max(1, props.w)\n\t\tconst scaledH = Math.max(1, props.h + props.growY)\n\t\tconst unscaledW = scaledW / scale\n\t\tconst unscaledH = scaledH / scale\n\n\t\tconst isEmptyLabel = isEmptyRichText(props.richText)\n\t\tconst unscaledLabelSize = isEmptyLabel\n\t\t\t? EMPTY_LABEL_SIZE\n\t\t\t: getUnscaledLabelSize(this.editor, shape)\n\n\t\tconst labelBounds = getLabelBounds(\n\t\t\tunscaledW,\n\t\t\tunscaledH,\n\t\t\tunscaledLabelSize,\n\t\t\tprops.size,\n\t\t\tprops.align,\n\t\t\tprops.verticalAlign,\n\t\t\tscale\n\t\t)\n\n\t\treturn new Group2d({\n\t\t\tchildren: [\n\t\t\t\tpathGeometry,\n\t\t\t\tnew Rectangle2d({\n\t\t\t\t\t...labelBounds,\n\t\t\t\t\tisFilled: true,\n\t\t\t\t\tisLabel: true,\n\t\t\t\t\texcludeFromShapeBounds: true,\n\t\t\t\t\tisEmptyLabel: isEmptyLabel,\n\t\t\t\t}),\n\t\t\t],\n\t\t})\n\t}\n\n\toverride getHandleSnapGeometry(shape: TLGeoShape): HandleSnapGeometry {\n\t\tconst geometry = this.getGeometry(shape)\n\t\t// we only want to snap handles to the outline of the shape - not to its label etc.\n\t\tconst outline = geometry.children[0]\n\t\tswitch (shape.props.geo) {\n\t\t\tcase 'arrow-down':\n\t\t\tcase 'arrow-left':\n\t\t\tcase 'arrow-right':\n\t\t\tcase 'arrow-up':\n\t\t\tcase 'check-box':\n\t\t\tcase 'diamond':\n\t\t\tcase 'hexagon':\n\t\t\tcase 'octagon':\n\t\t\tcase 'pentagon':\n\t\t\tcase 'rectangle':\n\t\t\tcase 'rhombus':\n\t\t\tcase 'rhombus-2':\n\t\t\tcase 'star':\n\t\t\tcase 'trapezoid':\n\t\t\tcase 'triangle':\n\t\t\tcase 'x-box':\n\t\t\t\t// poly-line type shapes hand snap points for each vertex & the center\n\t\t\t\treturn { outline: outline, points: [...outline.vertices, geometry.bounds.center] }\n\t\t\tcase 'cloud':\n\t\t\tcase 'ellipse':\n\t\t\tcase 'heart':\n\t\t\tcase 'oval':\n\t\t\t\t// blobby shapes only have a snap point in their center\n\t\t\t\treturn { outline: outline, points: [geometry.bounds.center] }\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(shape.props.geo)\n\t\t}\n\t}\n\n\toverride getText(shape: TLGeoShape) {\n\t\treturn renderPlaintextFromRichText(this.editor, shape.props.richText)\n\t}\n\n\toverride getFontFaces(shape: TLGeoShape) {\n\t\tif (isEmptyRichText(shape.props.richText)) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\t\treturn getFontsFromRichText(this.editor, shape.props.richText, {\n\t\t\tfamily: `tldraw_${shape.props.font}`,\n\t\t\tweight: 'normal',\n\t\t\tstyle: 'normal',\n\t\t})\n\t}\n\n\tcomponent(shape: TLGeoShape) {\n\t\tconst { id, type, props } = shape\n\t\tconst { fill, font, align, verticalAlign, size, richText } = props\n\t\tconst theme = useDefaultColorTheme()\n\t\tconst { editor } = this\n\t\tconst isOnlySelected = useValue(\n\t\t\t'isGeoOnlySelected',\n\t\t\t() => shape.id === editor.getOnlySelectedShapeId(),\n\t\t\t[editor]\n\t\t)\n\t\tconst isReadyForEditing = useIsReadyForEditing(editor, shape.id)\n\t\tconst isEmpty = isEmptyRichText(shape.props.richText)\n\t\tconst showHtmlContainer = isReadyForEditing || !isEmpty\n\t\tconst isForceSolid = useEfficientZoomThreshold(shape.props.scale * 0.25)\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<SVGContainer>\n\t\t\t\t\t<GeoShapeBody shape={shape} shouldScale={true} forceSolid={isForceSolid} />\n\t\t\t\t</SVGContainer>\n\t\t\t\t{showHtmlContainer && (\n\t\t\t\t\t<HTMLContainer\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\toverflow: 'hidden',\n\t\t\t\t\t\t\twidth: shape.props.w,\n\t\t\t\t\t\t\theight: shape.props.h + props.growY,\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t<RichTextLabel\n\t\t\t\t\t\t\tshapeId={id}\n\t\t\t\t\t\t\ttype={type}\n\t\t\t\t\t\t\tfont={font}\n\t\t\t\t\t\t\tfontSize={LABEL_FONT_SIZES[size] * shape.props.scale}\n\t\t\t\t\t\t\tlineHeight={TEXT_PROPS.lineHeight}\n\t\t\t\t\t\t\tpadding={LABEL_PADDING * shape.props.scale}\n\t\t\t\t\t\t\tfill={fill}\n\t\t\t\t\t\t\talign={align}\n\t\t\t\t\t\t\tverticalAlign={verticalAlign}\n\t\t\t\t\t\t\trichText={richText}\n\t\t\t\t\t\t\tisSelected={isOnlySelected}\n\t\t\t\t\t\t\tlabelColor={getColorValue(theme, props.labelColor, 'solid')}\n\t\t\t\t\t\t\twrap\n\t\t\t\t\t\t\tshowTextOutline={this.options.showTextOutline}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</HTMLContainer>\n\t\t\t\t)}\n\t\t\t\t{shape.props.url && <HyperlinkButton url={shape.props.url} />}\n\t\t\t</>\n\t\t)\n\t}\n\n\tindicator(shape: TLGeoShape) {\n\t\tconst isZoomedOut = useEfficientZoomThreshold(shape.props.scale * 0.25)\n\n\t\tconst { size, dash, scale } = shape.props\n\t\tconst strokeWidth = STROKE_SIZES[size]\n\n\t\tconst path = getGeoShapePath(shape)\n\n\t\treturn path.toSvg({\n\t\t\tstyle: dash === 'draw' ? 'draw' : 'solid',\n\t\t\tstrokeWidth: 1,\n\t\t\tpasses: 1,\n\t\t\trandomSeed: shape.id,\n\t\t\toffset: 0,\n\t\t\troundness: strokeWidth * 2 * scale,\n\t\t\tprops: { strokeWidth: undefined },\n\t\t\tforceSolid: isZoomedOut,\n\t\t})\n\t}\n\n\toverride toSvg(shape: TLGeoShape, ctx: SvgExportContext) {\n\t\tconst scale = shape.props.scale\n\t\t// We need to scale the shape to 1x for export\n\t\tconst newShape = {\n\t\t\t...shape,\n\t\t\tprops: {\n\t\t\t\t...shape.props,\n\t\t\t\tw: shape.props.w / scale,\n\t\t\t\th: (shape.props.h + shape.props.growY) / scale,\n\t\t\t\tgrowY: 0, // growY throws off the path calculations, so we set it to 0\n\t\t\t},\n\t\t}\n\t\tconst props = newShape.props\n\t\tctx.addExportDef(getFillDefForExport(props.fill))\n\n\t\tlet textEl\n\t\tif (!isEmptyRichText(props.richText)) {\n\t\t\tconst theme = getDefaultColorTheme(ctx)\n\t\t\tconst bounds = new Box(0, 0, props.w, (shape.props.h + shape.props.growY) / scale)\n\t\t\ttextEl = (\n\t\t\t\t<RichTextSVG\n\t\t\t\t\tfontSize={LABEL_FONT_SIZES[props.size]}\n\t\t\t\t\tfont={props.font}\n\t\t\t\t\talign={props.align}\n\t\t\t\t\tverticalAlign={props.verticalAlign}\n\t\t\t\t\trichText={props.richText}\n\t\t\t\t\tlabelColor={getColorValue(theme, props.labelColor, 'solid')}\n\t\t\t\t\tbounds={bounds}\n\t\t\t\t\tpadding={LABEL_PADDING}\n\t\t\t\t\tshowTextOutline={this.options.showTextOutline}\n\t\t\t\t/>\n\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<GeoShapeBody shouldScale={false} shape={newShape} forceSolid={false} />\n\t\t\t\t{textEl}\n\t\t\t</>\n\t\t)\n\t}\n\n\toverride getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {\n\t\treturn [getFillDefForCanvas()]\n\t}\n\n\toverride onResize(\n\t\tshape: TLGeoShape,\n\t\t{ handle, newPoint, scaleX, scaleY, initialShape }: TLResizeInfo<TLGeoShape>\n\t) {\n\t\tconst unscaledInitial = getUnscaledGeoProps(initialShape.props)\n\t\t// use the w/h from props here instead of the initialBounds here,\n\t\t// since cloud shapes calculated bounds can differ from the props w/h.\n\t\tlet unscaledW = unscaledInitial.w * scaleX\n\t\tlet unscaledH = (unscaledInitial.h + unscaledInitial.growY) * scaleY\n\t\tlet overShrinkX = 0\n\t\tlet overShrinkY = 0\n\n\t\tif (!isEmptyRichText(shape.props.richText)) {\n\t\t\t// Use initialShape for label measurement to hit the cache.\n\t\t\t// Creating a temp shape with new dimensions would break WeakCache and cause\n\t\t\t// expensive measurements on every resize frame.\n\t\t\tconst unscaledLabelSize = getUnscaledLabelSize(this.editor, initialShape)\n\n\t\t\tconst absUnscaledW = Math.abs(unscaledW)\n\t\t\tconst absUnscaledH = Math.abs(unscaledH)\n\n\t\t\t// Constrain to label size (primary constraint) and min size with label (secondary)\n\t\t\tconst constrainedW = Math.max(absUnscaledW, unscaledLabelSize.w, MIN_SIZE_WITH_LABEL)\n\t\t\tconst constrainedH = Math.max(absUnscaledH, unscaledLabelSize.h, MIN_SIZE_WITH_LABEL)\n\n\t\t\toverShrinkX = constrainedW - absUnscaledW\n\t\t\toverShrinkY = constrainedH - absUnscaledH\n\n\t\t\tunscaledW = constrainedW * Math.sign(unscaledW || 1)\n\t\t\tunscaledH = constrainedH * Math.sign(unscaledH || 1)\n\t\t}\n\n\t\tconst scaledW = unscaledW * shape.props.scale\n\t\tconst scaledH = unscaledH * shape.props.scale\n\n\t\tconst offset = new Vec(0, 0)\n\n\t\t// x offsets\n\n\t\tif (scaleX < 0) {\n\t\t\toffset.x += scaledW\n\t\t}\n\n\t\tif (handle === 'left' || handle === 'top_left' || handle === 'bottom_left') {\n\t\t\toffset.x += scaleX < 0 ? overShrinkX : -overShrinkX\n\t\t}\n\n\t\t// y offsets\n\n\t\tif (scaleY < 0) {\n\t\t\toffset.y += scaledH\n\t\t}\n\n\t\tif (handle === 'top' || handle === 'top_left' || handle === 'top_right') {\n\t\t\toffset.y += scaleY < 0 ? overShrinkY : -overShrinkY\n\t\t}\n\n\t\tconst { x, y } = offset.rot(shape.rotation).add(newPoint)\n\n\t\treturn {\n\t\t\tx,\n\t\t\ty,\n\t\t\tprops: {\n\t\t\t\tw: Math.max(Math.abs(scaledW), 1),\n\t\t\t\th: Math.max(Math.abs(scaledH), 1),\n\t\t\t\tgrowY: 0,\n\t\t\t},\n\t\t}\n\t}\n\n\toverride onBeforeCreate(shape: TLGeoShape) {\n\t\tconst { props } = shape\n\n\t\t// No text - ensure growY is 0\n\t\tif (isEmptyRichText(props.richText)) {\n\t\t\treturn props.growY !== 0 ? { ...shape, props: { ...props, growY: 0 } } : undefined\n\t\t}\n\n\t\t// Has text - calculate growY needed to fit label\n\t\tconst unscaledShapeH = props.h / props.scale\n\t\tconst unscaledLabelH = getUnscaledLabelSize(this.editor, shape).h\n\t\tconst unscaledGrowY = calculateGrowY(unscaledShapeH, unscaledLabelH, props.growY / props.scale)\n\n\t\tif (unscaledGrowY !== null) {\n\t\t\treturn {\n\t\t\t\t...shape,\n\t\t\t\tprops: { ...props, growY: unscaledGrowY * props.scale },\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onBeforeUpdate(prev: TLGeoShape, next: TLGeoShape) {\n\t\tconst { props: prevProps } = prev\n\t\tconst { props: nextProps } = next\n\n\t\t// No change to text, font, or size - no update needed\n\t\tif (\n\t\t\tisEqual(prevProps.richText, nextProps.richText) &&\n\t\t\tprevProps.font === nextProps.font &&\n\t\t\tprevProps.size === nextProps.size\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\tconst wasEmpty = isEmptyRichText(prevProps.richText)\n\t\tconst isEmpty = isEmptyRichText(nextProps.richText)\n\n\t\t// If label is empty and used to be empty, skip label measurement and dimension adjustment\n\t\tif (wasEmpty && isEmpty) {\n\t\t\treturn\n\t\t}\n\n\t\t// Text was removed - reset growY\n\t\tif (isEmpty) {\n\t\t\treturn nextProps.growY !== 0 ? { ...next, props: { ...nextProps, growY: 0 } } : undefined\n\t\t}\n\n\t\tconst unscaledPrev = getUnscaledGeoProps(prevProps)\n\t\tconst unscaledLabelSize = getUnscaledLabelSize(this.editor, next)\n\t\tconst { scale } = nextProps\n\n\t\t// Text was added for the first time - expand shape to fit (if wasEmpty and now there's text...\n\t\t// It might be just whitespace but it is faster to assume that it is NOT just whitespace and expand\n\t\t// the shape in either case (a label with just spaces text will be less performant but that's acceptable)\n\t\tif (wasEmpty && !isEmpty) {\n\t\t\tconst expanded = expandShapeForFirstLabel(unscaledPrev.w, unscaledPrev.h, unscaledLabelSize)\n\t\t\treturn {\n\t\t\t\t...next,\n\t\t\t\tprops: {\n\t\t\t\t\t...nextProps,\n\t\t\t\t\tw: expanded.w * scale,\n\t\t\t\t\th: expanded.h * scale,\n\t\t\t\t\tgrowY: 0,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\t// Text was modified - adjust dimensions to fit new label\n\t\tconst unscaledNextW = next.props.w / scale\n\t\tconst needsWidthExpand = unscaledLabelSize.w > unscaledNextW\n\t\tconst unscaledGrowY = calculateGrowY(unscaledPrev.h, unscaledLabelSize.h, unscaledPrev.growY)\n\n\t\tif (unscaledGrowY !== null || needsWidthExpand) {\n\t\t\treturn {\n\t\t\t\t...next,\n\t\t\t\tprops: {\n\t\t\t\t\t...nextProps,\n\t\t\t\t\tgrowY: (unscaledGrowY ?? unscaledPrev.growY) * scale,\n\t\t\t\t\tw: Math.max(unscaledNextW, unscaledLabelSize.w) * scale,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onDoubleClick(shape: TLGeoShape) {\n\t\t// Little easter egg: double-clicking a rectangle / checkbox while\n\t\t// holding alt will toggle between check-box and rectangle\n\t\tif (this.editor.inputs.getAltKey()) {\n\t\t\tswitch (shape.props.geo) {\n\t\t\t\tcase 'rectangle': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...shape,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tgeo: 'check-box' as const,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase 'check-box': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...shape,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tgeo: 'rectangle' as const,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn\n\t}\n\toverride getInterpolatedProps(\n\t\tstartShape: TLGeoShape,\n\t\tendShape: TLGeoShape,\n\t\tt: number\n\t): TLGeoShapeProps {\n\t\treturn {\n\t\t\t...(t > 0.5 ? endShape.props : startShape.props),\n\t\t\tw: lerp(startShape.props.w, endShape.props.w, t),\n\t\t\th: lerp(startShape.props.h, endShape.props.h, t),\n\t\t\tscale: lerp(startShape.props.scale, endShape.props.scale, t),\n\t\t}\n\t}\n}\n\n// imperfect but good enough, should be the width of the W in the font / size combo\nconst MIN_WIDTHS = Object.freeze({\n\ts: 12,\n\tm: 14,\n\tl: 16,\n\txl: 20,\n})\n\nconst EXTRA_PADDINGS = Object.freeze({\n\ts: 2,\n\tm: 3.5,\n\tl: 5,\n\txl: 10,\n})\n\nconst EMPTY_LABEL_SIZE = Object.freeze({ w: 0, h: 0 })\n\n// Margin between label edge and shape edge (in unscaled units)\nconst LABEL_EDGE_MARGIN = 8\n\n/** Calculate label bounds for hit testing */\nfunction getLabelBounds(\n\tunscaledShapeW: number,\n\tunscaledShapeH: number,\n\tunscaledLabelSize: { w: number; h: number },\n\tsize: TLGeoShapeProps['size'],\n\talign: TLGeoShapeProps['align'],\n\tverticalAlign: TLGeoShapeProps['verticalAlign'],\n\tscale: number\n): { x: number; y: number; width: number; height: number } {\n\t// Calculate minimum label dimensions based on font size and shape size\n\tconst unscaledMinWidth = Math.min(100, unscaledShapeW / 2)\n\tconst unscaledMinHeight = Math.min(\n\t\tLABEL_FONT_SIZES[size] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2,\n\t\tunscaledShapeH / 2\n\t)\n\n\t// Label dimensions: at least the measured size, but constrained to shape bounds\n\tconst unscaledLabelW = Math.min(\n\t\tunscaledShapeW,\n\t\tMath.max(\n\t\t\tunscaledLabelSize.w,\n\t\t\tMath.min(unscaledMinWidth, Math.max(1, unscaledShapeW - LABEL_EDGE_MARGIN))\n\t\t)\n\t)\n\tconst unscaledLabelH = Math.min(\n\t\tunscaledShapeH,\n\t\tMath.max(\n\t\t\tunscaledLabelSize.h,\n\t\t\tMath.min(unscaledMinHeight, Math.max(1, unscaledShapeH - LABEL_EDGE_MARGIN))\n\t\t)\n\t)\n\n\t// Calculate position based on alignment\n\tconst unscaledX =\n\t\talign === 'start'\n\t\t\t? 0\n\t\t\t: align === 'end'\n\t\t\t\t? unscaledShapeW - unscaledLabelW\n\t\t\t\t: (unscaledShapeW - unscaledLabelW) / 2\n\n\tconst unscaledY =\n\t\tverticalAlign === 'start'\n\t\t\t? 0\n\t\t\t: verticalAlign === 'end'\n\t\t\t\t? unscaledShapeH - unscaledLabelH\n\t\t\t\t: (unscaledShapeH - unscaledLabelH) / 2\n\n\treturn {\n\t\tx: unscaledX * scale,\n\t\ty: unscaledY * scale,\n\t\twidth: unscaledLabelW * scale,\n\t\theight: unscaledLabelH * scale,\n\t}\n}\n\n/** Get the unscaled dimensions from a geo shape's props */\nfunction getUnscaledGeoProps(props: TLGeoShapeProps) {\n\tconst { w, h, growY, scale } = props\n\treturn {\n\t\tw: w / scale,\n\t\th: h / scale,\n\t\tgrowY: growY / scale,\n\t}\n}\n\n/**\n * Calculate the growY needed to fit a label within a shape.\n * Returns null if no change is needed, otherwise returns the new unscaled growY value.\n */\nfunction calculateGrowY(\n\tunscaledShapeH: number,\n\tunscaledLabelH: number,\n\tunscaledCurrentGrowY: number\n): number | null {\n\tif (unscaledLabelH > unscaledShapeH) {\n\t\t// Label is taller than shape - need to grow\n\t\treturn unscaledLabelH - unscaledShapeH\n\t}\n\tif (unscaledCurrentGrowY > 0) {\n\t\t// Label fits and we have existing growY - reset it\n\t\treturn 0\n\t}\n\t// No change needed\n\treturn null\n}\n\n/**\n * Calculate expanded dimensions when adding a label to a shape for the first time.\n * Ensures the shape meets minimum size requirements and is square if originally small.\n */\nfunction expandShapeForFirstLabel(\n\tunscaledW: number,\n\tunscaledH: number,\n\tunscaledLabelSize: { w: number; h: number }\n): { w: number; h: number } {\n\tlet w = Math.max(unscaledW, unscaledLabelSize.w)\n\tlet h = Math.max(unscaledH, unscaledLabelSize.h)\n\n\t// If shape was smaller than min size in both dimensions, make it square\n\tif (unscaledW < MIN_SIZE_WITH_LABEL && unscaledH < MIN_SIZE_WITH_LABEL) {\n\t\tw = Math.max(w, MIN_SIZE_WITH_LABEL)\n\t\th = Math.max(h, MIN_SIZE_WITH_LABEL)\n\t\t// Make square by using the larger dimension\n\t\tconst maxDim = Math.max(w, h)\n\t\tw = maxDim\n\t\th = maxDim\n\t}\n\n\treturn { w, h }\n}\n\nconst labelSizesForGeo = new WeakCache<TLGeoShape, { w: number; h: number }>()\n\n// Returns cached label size for the shape. Don't call with empty rich text.\nfunction getUnscaledLabelSize(editor: Editor, shape: TLGeoShape) {\n\treturn labelSizesForGeo.get(shape, () => {\n\t\treturn measureUnscaledLabelSize(editor, shape)\n\t})\n}\n\n// This is the expensive part of the code so we want to avoid calling it if we can\nfunction measureUnscaledLabelSize(editor: Editor, shape: TLGeoShape) {\n\tconst { richText, font, size, w } = shape.props\n\n\tconst minWidth = MIN_WIDTHS[size]\n\n\tconst html = renderHtmlFromRichTextForMeasurement(editor, richText)\n\tconst textSize = editor.textMeasure.measureHtml(html, {\n\t\t...TEXT_PROPS,\n\t\tfontFamily: FONT_FAMILIES[font],\n\t\tfontSize: LABEL_FONT_SIZES[size],\n\t\tminWidth: minWidth,\n\t\tmaxWidth: Math.max(\n\t\t\t// Guard because a DOM nodes can't be less 0\n\t\t\t0,\n\t\t\t// A 'w' width that we're setting as the min-width\n\t\t\tMath.ceil(minWidth + EXTRA_PADDINGS[size]),\n\t\t\t// The actual text size\n\t\t\tMath.ceil(w / shape.props.scale - LABEL_PADDING * 2)\n\t\t),\n\t})\n\n\treturn {\n\t\tw: textSize.w + LABEL_PADDING * 2,\n\t\th: textSize.h + LABEL_PADDING * 2,\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
