---
id: quality-api-integration-to-core
version: 1.0.0
created: 2026-01-27
updated: 2026-01-27
changelog:
  - 1.0.0: 初始版本 - 将 Quality Platform API 集成到 Core 应用
---

# PRD - Quality Platform API Integration to Core

## 需求来源

Core 应用（`apps/core`）需要显示 Cecelia Quality Platform 的实时状态，提供 4 块核心内容的 API 端点。

## 核心目标

在现有的 Core 应用中添加 Quality Platform API 路由，读取 `cecelia-quality` 仓库的数据（state/queue/runs/db），为前端提供：

1. **全局 Health** - 系统健康状态
2. **Queue** - 队列状态 + 前 10 个任务
3. **Runs** - 最近 20 次运行
4. **Top Failures** - 失败清单

## 架构设计

```
前端 (React/Vue)
    │
    │ Fetch API
    ▼
Core 应用 (Express, Port 5211)
    │
    ├─ /api/cecelia (已有 - task tracker)
    ├─ /api/dev (已有)
    ├─ /api/engine (已有)
    └─ /api/quality (NEW) ← 新增 Quality Platform API
           │
           │ Read files
           ▼
    cecelia-quality 仓库
    (/home/xx/dev/cecelia-quality/)
    ├─ state/state.json
    ├─ queue/queue.jsonl
    ├─ runs/<runId>/
    └─ db/cecelia.db
```

## 技术实现

### 1. 新增 Quality API 模块

**目录结构**:
```
apps/core/src/
├── dashboard/
├── dev/
├── engine/
└── quality/              ← NEW
    ├── index.ts          ← 导出模块
    ├── routes.ts         ← API 路由
    ├── services/         ← 业务逻辑
    │   └── quality-reader.ts  ← 读取 cecelia-quality 数据
    └── types.ts          ← TypeScript 类型定义
```

### 2. Quality Reader Service

**功能**: 读取 cecelia-quality 仓库的数据

**文件**: `apps/core/src/quality/services/quality-reader.ts`

**实现**:

```typescript
import fs from 'fs';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

// Path to cecelia-quality repository
const QUALITY_REPO = process.env.QUALITY_REPO_PATH || '/home/xx/dev/cecelia-quality';
const STATE_FILE = path.join(QUALITY_REPO, 'state/state.json');
const QUEUE_FILE = path.join(QUALITY_REPO, 'queue/queue.jsonl');
const RUNS_DIR = path.join(QUALITY_REPO, 'runs');
const DB_FILE = path.join(QUALITY_REPO, 'db/cecelia.db');

export class QualityReader {
  // Read JSON file safely
  private readJSON<T>(filePath: string, fallback: T): T {
    try {
      if (!fs.existsSync(filePath)) return fallback;
      const content = fs.readFileSync(filePath, 'utf8');
      return JSON.parse(content);
    } catch (err) {
      console.error(`Error reading ${filePath}:`, err);
      return fallback;
    }
  }

  // Read JSONL file
  private readJSONL(filePath: string): any[] {
    try {
      if (!fs.existsSync(filePath)) return [];
      const content = fs.readFileSync(filePath, 'utf8');
      return content
        .split('\n')
        .filter(line => line.trim())
        .map(line => {
          try {
            return JSON.parse(line);
          } catch {
            return null;
          }
        })
        .filter(Boolean);
    } catch (err) {
      console.error(`Error reading ${filePath}:`, err);
      return [];
    }
  }

  // Query SQLite database
  private async queryDB(sql: string): Promise<any[]> {
    try {
      const { stdout } = await execAsync(`sqlite3 -json "${DB_FILE}" "${sql}"`);
      return JSON.parse(stdout || '[]');
    } catch (err) {
      console.error('Error querying DB:', err);
      return [];
    }
  }

  // Get system state
  async getSystemState() {
    const state = this.readJSON(STATE_FILE, {
      health: 'unknown',
      queueLength: 0,
      lastRun: null,
      stats: { totalTasks: 0, successRate: 0 }
    });

    const queue = this.readJSONL(QUEUE_FILE);
    const queueLength = queue.length;
    const priorityCounts = {
      P0: queue.filter(t => t.priority === 'P0').length,
      P1: queue.filter(t => t.priority === 'P1').length,
      P2: queue.filter(t => t.priority === 'P2').length
    };

    // Get system health from DB (if available)
    let systemHealth = null;
    if (fs.existsSync(DB_FILE)) {
      const health = await this.queryDB('SELECT * FROM system_health LIMIT 1;');
      if (health.length > 0) {
        systemHealth = health[0];
      }
    }

    return {
      health: state.health || 'ok',
      queueLength,
      priorityCounts,
      lastRun: state.lastRun,
      lastHeartbeat: state.lastHeartbeat,
      stats: state.stats,
      systemHealth,
      timestamp: new Date().toISOString()
    };
  }

  // Get queue status
  async getQueueStatus(limit = 10) {
    const queue = this.readJSONL(QUEUE_FILE);

    // Sort by priority
    const sorted = queue.sort((a, b) => {
      const priorityOrder = { P0: 0, P1: 1, P2: 2 };
      const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
      if (priorityDiff !== 0) return priorityDiff;
      return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();
    });

    return {
      total: queue.length,
      byPriority: {
        P0: queue.filter(t => t.priority === 'P0').length,
        P1: queue.filter(t => t.priority === 'P1').length,
        P2: queue.filter(t => t.priority === 'P2').length
      },
      tasks: sorted.slice(0, limit),
      timestamp: new Date().toISOString()
    };
  }

  // Get recent runs
  async getRecentRuns(limit = 20, status?: string) {
    try {
      if (!fs.existsSync(RUNS_DIR)) return { runs: [], stats: {} };

      const runDirs = fs.readdirSync(RUNS_DIR)
        .filter(name => fs.statSync(path.join(RUNS_DIR, name)).isDirectory())
        .map(name => {
          const runPath = path.join(RUNS_DIR, name);
          const stat = fs.statSync(runPath);
          const taskFile = path.join(runPath, 'task.json');
          const summaryFile = path.join(runPath, 'summary.json');
          const resultFile = path.join(runPath, 'result.json');

          const task = this.readJSON(taskFile, null);
          const summary = this.readJSON(summaryFile, null);
          const result = this.readJSON(resultFile, null);

          return {
            runId: name,
            createdAt: stat.mtime.toISOString(),
            task: task ? {
              taskId: task.taskId,
              intent: task.intent,
              priority: task.priority,
              source: task.source
            } : null,
            status: result?.status || summary?.status || 'unknown',
            duration: summary?.duration || null,
            exitCode: summary?.exitCode || result?.exitCode || null
          };
        })
        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

      // Filter by status if specified
      let filtered = runDirs;
      if (status) {
        filtered = runDirs.filter(r => r.status === status);
      }

      // Stats
      const stats = {
        total: runDirs.length,
        succeeded: runDirs.filter(r => r.status === 'succeeded' || r.status === 'completed').length,
        failed: runDirs.filter(r => r.status === 'failed').length,
        running: runDirs.filter(r => r.status === 'running').length
      };

      return {
        runs: filtered.slice(0, limit),
        stats,
        timestamp: new Date().toISOString()
      };
    } catch (err) {
      console.error('Error getting recent runs:', err);
      return { runs: [], stats: {} };
    }
  }

  // Get run detail
  async getRunDetail(runId: string) {
    const runPath = path.join(RUNS_DIR, runId);

    if (!fs.existsSync(runPath)) {
      return null;
    }

    const task = this.readJSON(path.join(runPath, 'task.json'), null);
    const summary = this.readJSON(path.join(runPath, 'summary.json'), null);
    const result = this.readJSON(path.join(runPath, 'result.json'), null);

    // Get logs (last 200 lines)
    const workerLog = path.join(runPath, 'worker.log');
    let logs = '';
    if (fs.existsSync(workerLog)) {
      const fullLog = fs.readFileSync(workerLog, 'utf8');
      const lines = fullLog.split('\n');
      logs = lines.slice(-200).join('\n');
    }

    // Get evidence files
    const evidencePath = path.join(runPath, 'evidence');
    let evidence: any[] = [];
    if (fs.existsSync(evidencePath)) {
      evidence = fs.readdirSync(evidencePath).map(filename => {
        const filePath = path.join(evidencePath, filename);
        const stat = fs.statSync(filePath);
        return {
          filename,
          type: filename.includes('.md') ? 'report' :
                filename.includes('.log') ? 'log' :
                filename.includes('.json') ? 'data' : 'other',
          size: stat.size,
          path: `/api/quality/runs/${runId}/evidence/${filename}`
        };
      });
    }

    return {
      runId,
      task,
      summary,
      result,
      evidence,
      logs,
      timestamp: new Date().toISOString()
    };
  }

  // Get top failures
  async getTopFailures(limit = 10) {
    const { runs } = await this.getRecentRuns(100);
    const failed = runs
      .filter(r => r.status === 'failed')
      .slice(0, limit)
      .map(r => ({
        runId: r.runId,
        taskId: r.task?.taskId,
        intent: r.task?.intent,
        priority: r.task?.priority,
        createdAt: r.createdAt,
        exitCode: r.exitCode
      }));

    return {
      failures: failed,
      total: failed.length,
      timestamp: new Date().toISOString()
    };
  }
}

export const qualityReader = new QualityReader();
```

### 3. Quality API Routes

**文件**: `apps/core/src/quality/routes.ts`

**实现**:

```typescript
import { Router, Request, Response } from 'express';
import { qualityReader } from './services/quality-reader.js';
import fs from 'fs';
import path from 'path';

const router = Router();

const QUALITY_REPO = process.env.QUALITY_REPO_PATH || '/home/xx/dev/cecelia-quality';
const RUNS_DIR = path.join(QUALITY_REPO, 'runs');

/**
 * GET /api/quality/state
 * Get global system state
 */
router.get('/state', async (_req: Request, res: Response) => {
  try {
    const state = await qualityReader.getSystemState();
    res.json(state);
  } catch (err) {
    console.error('Error in /api/quality/state:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * GET /api/quality/queue
 * Get queue status
 */
router.get('/queue', async (req: Request, res: Response) => {
  try {
    const limit = parseInt(req.query.limit as string, 10) || 10;
    const queue = await qualityReader.getQueueStatus(limit);
    res.json(queue);
  } catch (err) {
    console.error('Error in /api/quality/queue:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * GET /api/quality/runs
 * Get recent runs
 */
router.get('/runs', async (req: Request, res: Response) => {
  try {
    const limit = parseInt(req.query.limit as string, 10) || 20;
    const status = req.query.status as string | undefined;
    const runs = await qualityReader.getRecentRuns(limit, status);
    res.json(runs);
  } catch (err) {
    console.error('Error in /api/quality/runs:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * GET /api/quality/runs/:runId
 * Get run detail
 */
router.get('/runs/:runId', async (req: Request, res: Response) => {
  try {
    const { runId } = req.params;
    const detail = await qualityReader.getRunDetail(runId);

    if (!detail) {
      return res.status(404).json({ error: 'Run not found' });
    }

    res.json(detail);
  } catch (err) {
    console.error('Error in /api/quality/runs/:runId:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * GET /api/quality/runs/:runId/evidence/:filename
 * Download evidence file
 */
router.get('/runs/:runId/evidence/:filename', (req: Request, res: Response) => {
  try {
    const { runId, filename } = req.params;
    const filePath = path.join(RUNS_DIR, runId, 'evidence', filename);

    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ error: 'File not found' });
    }

    // Set content type
    const ext = path.extname(filename).toLowerCase();
    const contentType = {
      '.md': 'text/markdown',
      '.log': 'text/plain',
      '.json': 'application/json',
      '.txt': 'text/plain'
    }[ext] || 'application/octet-stream';

    res.setHeader('Content-Type', contentType);
    res.sendFile(filePath);
  } catch (err) {
    console.error('Error serving evidence file:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * GET /api/quality/failures
 * Get top failures
 */
router.get('/failures', async (req: Request, res: Response) => {
  try {
    const limit = parseInt(req.query.limit as string, 10) || 10;
    const failures = await qualityReader.getTopFailures(limit);
    res.json(failures);
  } catch (err) {
    console.error('Error in /api/quality/failures:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * GET /api/quality/health
 * Health check
 */
router.get('/health', (_req: Request, res: Response) => {
  res.json({
    status: 'healthy',
    service: 'quality-api',
    version: '1.0.0',
    timestamp: new Date().toISOString()
  });
});

export default router;
```

### 4. 集成到 Core Server

**文件**: `apps/core/src/dashboard/server.ts`

**修改** (添加一行):

```typescript
import qualityRoutes from '../quality/routes.js';

// ...

// Quality Platform API routes
app.use('/api/quality', qualityRoutes);
```

### 5. TypeScript 类型定义

**文件**: `apps/core/src/quality/types.ts`

```typescript
export interface SystemState {
  health: 'ok' | 'degraded' | 'unhealthy' | 'unknown';
  queueLength: number;
  priorityCounts: {
    P0: number;
    P1: number;
    P2: number;
  };
  lastRun: {
    taskId: string;
    completedAt: string;
    status: string;
  } | null;
  lastHeartbeat: string | null;
  stats: {
    totalTasks: number;
    successRate: number;
  };
  systemHealth: any;
  timestamp: string;
}

export interface QueueStatus {
  total: number;
  byPriority: {
    P0: number;
    P1: number;
    P2: number;
  };
  tasks: Task[];
  timestamp: string;
}

export interface Task {
  taskId: string;
  source: string;
  intent: string;
  priority: string;
  payload: any;
  createdAt: string;
}

export interface Run {
  runId: string;
  createdAt: string;
  task: {
    taskId: string;
    intent: string;
    priority: string;
    source: string;
  } | null;
  status: string;
  duration: number | null;
  exitCode: number | null;
}

export interface RunsResponse {
  runs: Run[];
  stats: {
    total: number;
    succeeded: number;
    failed: number;
    running: number;
  };
  timestamp: string;
}

export interface RunDetail {
  runId: string;
  task: any;
  summary: any;
  result: any;
  evidence: Evidence[];
  logs: string;
  timestamp: string;
}

export interface Evidence {
  filename: string;
  type: string;
  size: number;
  path: string;
}

export interface FailuresResponse {
  failures: Failure[];
  total: number;
  timestamp: string;
}

export interface Failure {
  runId: string;
  taskId: string;
  intent: string;
  priority: string;
  createdAt: string;
  exitCode: number;
}
```

## 验收标准

### P0 - API 集成

- [ ] `apps/core/src/quality/` 目录已创建
- [ ] `quality/services/quality-reader.ts` 已实现，能读取 cecelia-quality 数据
- [ ] `quality/routes.ts` 已实现，包含 7 个端点
- [ ] `quality/types.ts` 已创建，包含所有类型定义
- [ ] `dashboard/server.ts` 已更新，添加 `/api/quality` 路由
- [ ] 所有端点返回正确的数据

### P0 - 测试

- [ ] `GET /api/quality/health` 返回 200
- [ ] `GET /api/quality/state` 返回系统状态
- [ ] `GET /api/quality/queue` 返回队列数据
- [ ] `GET /api/quality/runs` 返回运行列表
- [ ] `GET /api/quality/runs/:runId` 返回运行详情
- [ ] `GET /api/quality/failures` 返回失败列表
- [ ] 证据文件下载正常

### P0 - TypeScript

- [ ] 无 TypeScript 错误
- [ ] `npm run typecheck` 通过
- [ ] `npm run build` 成功

## 测试方案

### 单元测试

```bash
# 1. 启动 Core 服务器
cd apps/core
npm run dev

# 2. 测试 Quality API
curl http://localhost:5211/api/quality/health | jq .
curl http://localhost:5211/api/quality/state | jq .
curl http://localhost:5211/api/quality/queue | jq .
curl http://localhost:5211/api/quality/runs?limit=5 | jq .
curl http://localhost:5211/api/quality/failures | jq .
```

### 集成测试

```bash
# 1. 在 cecelia-quality 仓库提交任务
cd /home/xx/dev/cecelia-quality
bash gateway/gateway.sh add cloudcode runQA P0 '{"project":"cecelia-quality"}'

# 2. 执行任务
bash worker/worker.sh

# 3. 从 Core API 查看结果
curl http://localhost:5211/api/quality/state | jq .
curl http://localhost:5211/api/quality/runs?limit=1 | jq .
```

## 环境变量

**新增**:

```bash
# apps/core/.env (or environment)
QUALITY_REPO_PATH=/home/xx/dev/cecelia-quality
```

## 依赖关系

**前置条件**:
- cecelia-quality 仓库已完成 Gateway/Worker/State 系统
- cecelia-quality 数据目录存在且可读

**无需新增 npm 依赖**:
- 所有功能使用 Node.js 内置模块 (fs, path, child_process)

## 部署方案

### 开发环境

```bash
cd /home/xx/dev/cecelia-workspace/apps/core
npm run dev
```

### 生产环境

```bash
# 构建
npm run build

# 启动
npm start

# 或使用 PM2
pm2 start dist/dashboard/server.js --name core-server
```

## 风险和缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 跨仓库读取数据 | 文件路径错误 | 环境变量配置，默认路径 |
| SQLite 权限问题 | 无法查询数据库 | 确保 Core 进程有读取权限 |
| 大量 runs 目录 | 性能问题 | 限制读取数量，考虑缓存 |

## 优先级

**P0** - 必须完成

## 预计工时

- 开发: 2 小时
- 测试: 30 分钟
- 文档: 30 分钟

**总计**: 3 小时

---

**责任人**: AI (Claude)
**验收人**: User
