---
id: prd-planner-agent
version: 2.0.0
created: 2026-01-31
updated: 2026-01-31
changelog:
  - 2.0.0: 重写，基于确定的三层数据模型和动态规划机制
  - 1.0.0: 初始版本
---

# PRD - Planner Agent：Brain 的规划层

## 背景

Brain 系统现在能**执行**（tick dispatch → cecelia-run → /dev），但不能**规划**。

现状：
- 用户必须手动创建 OKR、手动拆 Task、手动排优先级
- `intent.js`、`decomposer.js`、`templates.js` 都存在但没串起来
- 没有东西能把一个大目标动态拆成可执行的 Task

## 核心概念定义

### 三个 Database

| Database | 包含 | 说明 |
|----------|------|------|
| **OKR** | Area → O → KR | 目标体系，KR 可跨 repo |
| **Project** | Project（绑定 repo_path） | 执行单位，1 Project = 1 repo |
| **Task** | Task（绑定 Project + KR） | 最小执行单位，1 Task = 1 run = 1 PR |

### 每层定义

**Area**（人生领域）
```yaml
title: "AI Coding"  # 大领域，长期不变
# DB: 暂用 working_memory 或独立表，不急
```

**O (Objective)**
```yaml
title: "Cecelia 自驱进化"  # 方向性，不量化
why: "为什么做"
success_criteria: "什么算成功（定性）"
priority: P0 | P1 | P2
# DB: goals 表, type='objective', parent_id=null
```

**KR (Key Result)**
```yaml
title: "Brain 能自动 dispatch 并完成任务"  # 可衡量
metric: "自动完成的 PR 数"
target: 10
current: 0
deadline: "2026-03-01"
weight: 0.3  # 在 O 中的权重
# DB: goals 表, type='key_result', parent_id=O.id
# 注意：KR 可关联多个 Project（跨 repo）
```

**Project**
```yaml
title: "tick dispatch 增强"
repo_path: "/home/xx/dev/cecelia-workspace"  # 必须绑定 repo
scope: "在 cecelia-workspace 中完成的改动"
prd_content: "Project PRD 内容..."  # 大蓝图
kr_ids: ["kr-1", "kr-2"]  # 关联的 KR（可多个）
# DB: projects 表
# 硬约束：1 Project = 1 repo
```

**Task**
```yaml
title: "tick.js 加 dispatch 逻辑"
priority: P0
project_id: "xxx"  # 必须绑定 Project
goal_id: "kr-1"    # 关联 KR
depends_on: ["task-id-1"]
payload:
  prd_path: ".prd-xxx.md"  # Feature PRD
  context: "上一个 Task 的产出..."
# DB: tasks 表
# 硬约束：1 Task = 1 run = 1 PR（单 repo）
```

### 五条硬约束

1. **Task 必须绑定一个 Project**
2. **Project 必须绑定一个 repo_path**
3. **一个 Task = 一个 PR（单 repo）**
4. **KR 可以关联多个 Project**
5. **Planner 每次 tick 只生成一个 Task**

### 文档层级

| 文档 | 级别 | 用途 |
|------|------|------|
| **Project PRD** | 大蓝图 | 描述整个 Project 要做什么，Planner 读它来拆 Task |
| **Feature PRD** | 小的 | 每个 Task 的具体 PRD，/dev 直接用 |
| **DoD** | Task 级 | /dev 流程中生成 |

## 目标

创建 `planner.js`，作为 Brain 的规划层，实现**动态规划循环**：

```
每次 tick:
  1. 看 KR 目标和当前状态
  2. 决定下一步推进哪个 repo 的哪个 Project
  3. 在那个 Project 里只产出下一个 Task（= 1 PR）
  4. dispatch → 执行 → 完成
  5. 回来看结果，再决定下一步
```

**不是一次性拆完，是每轮只拆一个 Task。**

## 核心改动

### 1. 新增 `planner.js`

```javascript
/**
 * Planner 主入口 - 每次 tick 调用
 * 返回下一个要执行的 Task，或 null（没事做）
 */
async function planNextTask() {
  // 1. 获取全局状态
  const state = await getGlobalState();
  // { objectives, keyResults, projects, activeTasks, recentCompleted, focus }

  // 2. 选择当前最该推进的 KR
  const targetKR = selectTargetKR(state);
  if (!targetKR) return null;

  // 3. 找到这个 KR 下该推进的 Project
  const targetProject = selectTargetProject(targetKR, state);
  if (!targetProject) {
    // KR 下没有 Project → 需要创建 Project（后续版本）
    return null;
  }

  // 4. 基于 Project 当前进度，生成下一个 Task
  const task = await generateNextTask(targetKR, targetProject, state);

  // 5. 写入数据库
  if (task) {
    await persistTask(task);
  }

  return task;
}
```

### 2. `getGlobalState()` — 全局状态感知

```javascript
async function getGlobalState() {
  return {
    objectives: /* goals WHERE type='objective' AND status != 'completed' */,
    keyResults: /* goals WHERE type='key_result' AND status != 'completed' */,
    projects: /* projects WITH repo_path */,
    activeTasks: /* tasks WHERE status IN ('queued', 'in_progress') */,
    recentCompleted: /* tasks WHERE status='completed' ORDER BY completed_at DESC LIMIT 10 */,
    focus: await getDailyFocus()
  };
}
```

### 3. `selectTargetKR()` — 选择最该推进的 KR

```javascript
function selectTargetKR(state) {
  // 优先级：
  // 1. 当前 focus 关联的 KR
  // 2. P0 > P1 > P2
  // 3. 进度低但离 deadline 近的
  // 4. 有 queued task 的（说明已经拆过但没执行完）
}
```

### 4. `selectTargetProject()` — 选择该推进的 Project

```javascript
function selectTargetProject(kr, state) {
  // KR 关联多个 Project 时：
  // 1. 有 queued task 的 Project 优先（已拆未执行）
  // 2. 进度最低的 Project
  // 3. 有依赖关系的按依赖顺序（先做被依赖的）
}
```

### 5. `generateNextTask()` — 基于上下文生成下一个 Task

```javascript
async function generateNextTask(kr, project, state) {
  // 1. 读取 Project PRD
  // 2. 看最近完成的 Task（上一步产出了什么）
  // 3. 看还有什么 queued task（之前拆的还没做的）
  // 4. 如果有 queued → 返回最高优先级的那个
  // 5. 如果没有 → 根据 PRD + 已完成的进度，生成新 Task
  //    - 生成 Feature PRD（.prd-xxx.md）
  //    - 创建 Task 记录

  // 第一版：如果 Project 有 queued task 就返回它
  // 如果没有，标记 Project 为需要手动规划
  // 后续版本：用 LLM 自动生成
}
```

### 6. 集成到 tick

在 `executeTick()` 的 dispatch 阶段之前：

```javascript
// Step: Planning（新增）
// 如果没有 queued task，调 planner 生成
const queuedCount = await getQueuedTaskCount(goalIds);
if (queuedCount === 0) {
  const planned = await planNextTask();
  if (planned) {
    tickActions.push({ action: 'plan', task_id: planned.id, title: planned.title });
  }
}

// Step: Dispatch（已有）
const dispatchResult = await dispatchNextTask(goalIds);
```

### 7. API 端点

```
POST /api/brain/plan
Body: { input: "自然语言或结构化数据", dry_run: false }
Response: {
  level: "kr" | "project" | "task",
  action: "create" | "update",
  created: { goals: [...], projects: [...], tasks: [...] },
  linked_to: { kr: {...}, project: {...} }
}

GET /api/brain/plan/status
Response: {
  target_kr: { id, title, progress },
  target_project: { id, title, repo_path },
  queued_tasks: [...],
  last_completed: {...}
}
```

### 8. 数据库改动

**projects 表增加字段**：
```sql
ALTER TABLE projects ADD COLUMN IF NOT EXISTS repo_path TEXT;
ALTER TABLE projects ADD COLUMN IF NOT EXISTS prd_content TEXT;
ALTER TABLE projects ADD COLUMN IF NOT EXISTS scope TEXT;
```

**新增 project_kr_links 表**（KR 关联多个 Project）：
```sql
CREATE TABLE IF NOT EXISTS project_kr_links (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID REFERENCES projects(id),
  kr_id UUID REFERENCES goals(id),
  created_at TIMESTAMP DEFAULT NOW()
);
```

**tasks 表确认字段**：
- `project_id` — 已有
- `goal_id` — 已有（指向 KR）
- `payload.prd_path` — Feature PRD 路径
- `payload.context` — 上一个 Task 的产出

## 不做什么

- ❌ 第一版不用 LLM 自动生成 Task（纯规则：有 queued 就 dispatch，没有就等手动创建）
- ❌ 不做 Area 管理（暂时不需要）
- ❌ 不自动创建 Project（需要人工给 Project PRD）
- ❌ 不做跨 repo 的原子操作（每个 Task 严格单 repo）

## 成功标准

- [ ] `planNextTask()` 能选出最该推进的 KR → Project → Task
- [ ] 没有 queued task 时，planner 能标记"需要规划"
- [ ] tick 集成 planner：queued=0 时自动触发规划
- [ ] `/api/brain/plan` 接受自然语言输入，创建正确层级的记录
- [ ] `/api/brain/plan/status` 返回当前规划状态
- [ ] Project 表有 repo_path 字段，KR 可关联多个 Project
- [ ] 五条硬约束在代码中强制执行

## 影响范围

| 文件 | 改动 |
|------|------|
| 新增 apps/core/src/brain/planner.js | 规划 Agent 主逻辑 |
| apps/core/src/brain/routes.js | 新增 /api/brain/plan 端点 |
| apps/core/src/brain/tick.js | dispatch 前集成 planner |
| 新增 migration | projects 加字段 + project_kr_links 表 |
| 新增 planner.test.js | 单元测试 |

## 演进路线

| 版本 | 能力 |
|------|------|
| **v1（本次）** | 选 KR → 选 Project → dispatch 已有 Task；手动创建 Task |
| **v2** | 基于 Project PRD 自动生成 Feature PRD + Task（用 LLM） |
| **v3** | 基于 KR 自动创建 Project + Project PRD |
| **v4** | 基于 O 自动拆 KR |
