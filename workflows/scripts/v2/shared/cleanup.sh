#!/bin/bash
#
# 收尾阶段脚本
# 负责：生成执行报告、Git 提交推送、更新 Notion 状态和报告
#
# 用法: cleanup.sh <run_id> <task_id> <passed> [retry_count]
#
# 参数:
#   run_id      - 运行 ID
#   task_id     - Notion 任务 ID
#   passed      - true/false 质检是否通过
#   retry_count - 返工次数（可选，默认 0）
#
# 输出:
#   - 返回值: 0=成功, 非0=失败
#

set -e
set -o pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# 加载工具函数
source "$SCRIPT_DIR/utils.sh"

# ============================================================
# 参数解析
# ============================================================
RUN_ID="${1:-}"
TASK_ID="${2:-}"
PASSED="${3:-false}"
RETRY_COUNT="${4:-0}"

if [[ -z "$RUN_ID" || -z "$TASK_ID" ]]; then
  log_error "用法: cleanup.sh <run_id> <task_id> <passed> [retry_count]"
  # WORK_DIR 尚未定义，跳过 error.json
  exit 1
fi

WORK_DIR="/home/xx/data/runs/$RUN_ID"
LOG_FILE="$WORK_DIR/logs/cleanup.log"
REPORT_FILE="$WORK_DIR/execution_report.md"

# 加载环境变量（带安全检查）
if [[ -f "$WORK_DIR/env.sh" ]]; then
  # P0 安全检查: 禁止危险命令注入
  # 只允许简单的变量赋值（VAR=value 或 export VAR=value）
  DANGEROUS_PATTERNS=(
    'rm '
    'rm$'
    'curl '
    'wget '
    'eval '
    'exec '
    '\$\('
    '`'
    '>'
    '<'
    '|'
    ';'
    '&&'
    '\|\|'
    'sudo '
    'chmod '
    'chown '
    'kill '
    'pkill '
    'mkfifo '
    '/dev/'
    'nc '
    'netcat '
    'bash '
    'sh '
    'python '
    'perl '
    'ruby '
    'node '
  )

  ENV_CONTENT=$(cat "$WORK_DIR/env.sh" 2>/dev/null) || {
    log_warn "无法读取 env.sh"
    ENV_CONTENT=""
  }

  SAFE_TO_SOURCE=true
  for pattern in "${DANGEROUS_PATTERNS[@]}"; do
    if echo "$ENV_CONTENT" | grep -qE "$pattern"; then
      log_error "env.sh 包含危险命令模式: $pattern，拒绝加载"
      SAFE_TO_SOURCE=false
      break
    fi
  done

  # 额外检查：只允许 export VAR=value 或 VAR=value 格式的行
  if [[ "$SAFE_TO_SOURCE" == "true" ]]; then
    # 过滤掉空行和注释，检查剩余行是否符合变量赋值格式
    INVALID_LINES=$(echo "$ENV_CONTENT" | grep -vE '^\s*$|^\s*#|^(export\s+)?[A-Za-z_][A-Za-z0-9_]*=' || true)
    if [[ -n "$INVALID_LINES" ]]; then
      log_error "env.sh 包含非变量赋值语句，拒绝加载"
      log_error "无效行: $(echo "$INVALID_LINES" | head -3)"
      SAFE_TO_SOURCE=false
    fi
  fi

  if [[ "$SAFE_TO_SOURCE" == "true" ]]; then
    source "$WORK_DIR/env.sh" || log_warn "env.sh 加载失败"
  fi
fi

# 验证关键变量
if [[ -z "$PROJECT_DIR" ]]; then
  PROJECT_DIR="/home/xx/dev/zenithjoy-autopilot"
  log_warn "PROJECT_DIR 未定义，使用默认值: $PROJECT_DIR"
fi

log_info "=========================================="
log_info "收尾阶段开始"
log_info "Run ID: $RUN_ID"
log_info "Task ID: $TASK_ID"
log_info "质检结果: $PASSED"
log_info "返工次数: $RETRY_COUNT"
log_info "=========================================="

# ============================================================
# 步骤 1: 生成执行报告
# ============================================================
log_info "[1/5] 生成执行报告..."

# 读取任务信息
TASK_NAME=""
CODING_TYPE=""
if [[ -f "$WORK_DIR/task_info.json" ]]; then
  TASK_NAME=$(jq -r '.task_name // "Unknown Task"' "$WORK_DIR/task_info.json")
  CODING_TYPE=$(jq -r '.coding_type // "unknown"' "$WORK_DIR/task_info.json")
fi

# 读取质检报告
QUALITY_SCORE="N/A"
QUALITY_DETAILS=""
if [[ -f "$WORK_DIR/quality_report.json" ]]; then
  QUALITY_SCORE=$(jq -r '.score // "N/A"' "$WORK_DIR/quality_report.json")
  QUALITY_DETAILS=$(jq -r '.details // ""' "$WORK_DIR/quality_report.json" 2>/dev/null || echo "")
fi

# 收集错误信息
ERROR_MESSAGES=""
if [[ -f "$WORK_DIR/error.json" ]]; then
  ERROR_MESSAGES=$(jq -r '.message // .error // ""' "$WORK_DIR/error.json" 2>/dev/null || echo "")
fi

# 从日志中提取关键错误
LOG_ERRORS=""
for logfile in "$WORK_DIR/logs"/*.log; do
  if [[ -f "$logfile" ]]; then
    errors=$(grep -E "\[ERROR\]" "$logfile" 2>/dev/null | tail -10 || true)
    if [[ -n "$errors" ]]; then
      LOG_ERRORS="${LOG_ERRORS}${errors}"$'\n'
    fi
  fi
done

# 读取产出物信息
ARTIFACTS_INFO=""
if [[ -f "$WORK_DIR/result.json" ]]; then
  ARTIFACTS_INFO=$(jq -r '.artifacts // [] | .[] | "- " + (.path // .name // "unknown")' "$WORK_DIR/result.json" 2>/dev/null || echo "")
fi

# 生成报告
TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
BRANCH_NAME="${BRANCH_NAME:-feature/$TASK_ID}"

if [[ "$PASSED" == "true" ]]; then
  RESULT_EMOJI="SUCCESS"
  RESULT_STATUS="成功"
else
  RESULT_EMOJI="FAILED"
  RESULT_STATUS="失败"
fi

cat > "$REPORT_FILE" << EOF
# 执行报告 [$RESULT_EMOJI]

## 基本信息
- 任务: ${TASK_NAME}
- 类型: ${CODING_TYPE}
- 状态: ${RESULT_STATUS}
- 执行时间: ${TIMESTAMP}
- Run ID: ${RUN_ID}
- 分支: ${BRANCH_NAME}
- 重试次数: ${RETRY_COUNT}

## 质检结果
- 分数: ${QUALITY_SCORE}/100
EOF

if [[ -n "$QUALITY_DETAILS" && "$QUALITY_DETAILS" != "null" ]]; then
  echo "- 详情: ${QUALITY_DETAILS}" >> "$REPORT_FILE"
fi

if [[ -n "$ARTIFACTS_INFO" ]]; then
  cat >> "$REPORT_FILE" << EOF

## 产出物
${ARTIFACTS_INFO}
EOF
fi

if [[ "$PASSED" != "true" ]]; then
  cat >> "$REPORT_FILE" << EOF

## 失败原因
${ERROR_MESSAGES:-未知错误，请查看日志}

## 错误日志
${LOG_ERRORS:-无错误日志}

## 下次重试建议
1. 检查上述错误信息
2. 确认目标目录/文件是否存在
3. 检查依赖是否完整
4. 如需人工介入，请查看分支: ${BRANCH_NAME}
EOF
fi

cat >> "$REPORT_FILE" << EOF

---
Generated by AI Factory v2 @ ${TIMESTAMP}
EOF

log_info "执行报告已生成: $REPORT_FILE"

# ============================================================
# 步骤 2: Git 提交
# ============================================================
log_info "[2/5] Git 提交..."

cd "$PROJECT_DIR"

# 检查是否有更改需要提交
if [[ -n "$(git status --porcelain)" ]]; then
  COMMIT_TYPE="feat"
  COMMIT_SUFFIX=""

  if [[ "$PASSED" != "true" ]]; then
    COMMIT_TYPE="wip"
    COMMIT_SUFFIX=" (需人工处理)"
  elif [[ "$RETRY_COUNT" -gt 0 ]]; then
    COMMIT_SUFFIX=" [retry-$RETRY_COUNT]"
  fi

  COMMIT_MSG="${COMMIT_TYPE}(${TASK_ID:0:8}): ${TASK_NAME}${COMMIT_SUFFIX}

Task: https://notion.so/${TASK_ID}
Run ID: $RUN_ID
Quality Score: $QUALITY_SCORE/100
Retry Count: $RETRY_COUNT

Generated by AI Factory v2

Co-Authored-By: Claude <noreply@anthropic.com>"

  git add . -- ':!.env*' ':!*.key' ':!*credentials*' ':!*secret*'

  if ! git diff --cached --quiet; then
    if ! git commit -m "$COMMIT_MSG"; then
      log_error "Git commit 失败"
    else
      log_info "Git 提交完成"
    fi
  else
    log_info "没有更改需要提交"
  fi
else
  log_info "没有更改需要提交"
fi

# ============================================================
# 步骤 3: Git 推送
# ============================================================
log_info "[3/5] Git 推送..."

PUSH_SUCCESS=false
if git push origin "$BRANCH_NAME" 2>/dev/null; then
  PUSH_SUCCESS=true
elif git push -u origin "$BRANCH_NAME" 2>/dev/null; then
  PUSH_SUCCESS=true
fi

if [[ "$PUSH_SUCCESS" == "true" ]]; then
  log_info "Git 推送完成: $BRANCH_NAME"
else
  log_warn "Git push 失败，分支仅存在于本地"
fi

# ============================================================
# 步骤 4: 更新 Notion（状态 + 报告）
# ============================================================
log_info "[4/5] 更新 Notion..."

if [[ "$PASSED" == "true" ]]; then
  NEW_STATUS="AI Done"
  log_info "质检通过，状态更新为: AI Done"
else
  NEW_STATUS="AI Failed"
  log_info "质检失败，状态更新为: AI Failed"
fi

# 更新状态
update_notion_status "$TASK_ID" "$NEW_STATUS" || log_warn "更新 Notion 状态失败"

# 将报告写入 Notion 页面
load_secrets
if [[ -n "$NOTION_API_KEY" && -f "$REPORT_FILE" ]]; then
  log_info "写入执行报告到 Notion..."

  REPORT_CONTENT=$(cat "$REPORT_FILE" | head -c 1900)

  NOTION_BLOCK=$(jq -n \
    --arg content "$REPORT_CONTENT" \
    --arg run_id "$RUN_ID" \
    '{
      children: [
        {
          object: "block",
          type: "divider",
          divider: {}
        },
        {
          object: "block",
          type: "code",
          code: {
            rich_text: [{type: "text", text: {content: $content}}],
            language: "markdown",
            caption: [{type: "text", text: {content: ("Run: " + $run_id)}}]
          }
        }
      ]
    }')

  if curl -sf --connect-timeout 10 --max-time 30 -X PATCH \
    "https://api.notion.com/v1/blocks/$TASK_ID/children" \
    -H "Authorization: Bearer $NOTION_API_KEY" \
    -H "Notion-Version: 2022-06-28" \
    -H "Content-Type: application/json" \
    -d "$NOTION_BLOCK" > /dev/null 2>&1; then
    log_info "执行报告已写入 Notion"
  else
    log_warn "写入 Notion 报告失败"
  fi
fi

# ============================================================
# 步骤 5: Webhook 通知 (Execution Callback)
# ============================================================
log_info "[5/6] 发送 Webhook 通知..."

WEBHOOK_URL="http://localhost:5679/webhook/execution-callback"

# 检查是否是 Feature Check (Daily Highlight = true 的任务)
IS_FEATURE_CHECK=false
if [[ -f "$WORK_DIR/task_info.json" ]]; then
  DAILY_HIGHLIGHT=$(jq -r '.daily_highlight // false' "$WORK_DIR/task_info.json" 2>/dev/null || echo "false")
  if [[ "$DAILY_HIGHLIGHT" == "true" ]]; then
    IS_FEATURE_CHECK=true
  fi
fi

# 构建 Webhook payload
WEBHOOK_PAYLOAD=$(jq -n \
  --arg task_id "$TASK_ID" \
  --arg status "$NEW_STATUS" \
  --arg run_id "$RUN_ID" \
  --arg coding_type "$CODING_TYPE" \
  --arg task_name "$TASK_NAME" \
  --arg quality_score "$QUALITY_SCORE" \
  --argjson is_feature_check "$IS_FEATURE_CHECK" \
  '{
    task_id: $task_id,
    status: $status,
    run_id: $run_id,
    coding_type: $coding_type,
    task_name: $task_name,
    quality_score: ($quality_score | tonumber? // 0),
    is_feature_check: $is_feature_check
  }')

# 发送 Webhook 通知（带重试机制）
WEBHOOK_MAX_RETRIES=3
WEBHOOK_RETRY_DELAY=2
WEBHOOK_SUCCESS=false

for i in $(seq 1 $WEBHOOK_MAX_RETRIES); do
  if curl -sf --connect-timeout 10 --max-time 30 -X POST "$WEBHOOK_URL" \
    -H "Content-Type: application/json" \
    -d "$WEBHOOK_PAYLOAD" > /dev/null 2>&1; then
    WEBHOOK_SUCCESS=true
    log_info "Webhook 通知已发送 (尝试 $i/$WEBHOOK_MAX_RETRIES)"
    break
  else
    if [[ $i -lt $WEBHOOK_MAX_RETRIES ]]; then
      log_warn "Webhook 通知失败，${WEBHOOK_RETRY_DELAY}秒后重试 ($i/$WEBHOOK_MAX_RETRIES)"
      sleep $WEBHOOK_RETRY_DELAY
    fi
  fi
done

if [[ "$WEBHOOK_SUCCESS" != "true" ]]; then
  log_warn "Webhook 通知失败（已重试 $WEBHOOK_MAX_RETRIES 次），任务状态可能需要手动同步"
fi

# ============================================================
# 步骤 6: 清理
# ============================================================
log_info "[6/6] 清理..."

log_info "运行目录保留: $WORK_DIR"

RUNS_DIR="/home/xx/data/runs"
ALL_OLD=$(find "$RUNS_DIR" -maxdepth 1 -type d -name "20*" -mtime +7 2>/dev/null | sort)
if [[ -z "$ALL_OLD" ]]; then
  OLD_COUNT=0
else
  OLD_COUNT=$(echo "$ALL_OLD" | wc -l)
fi
OLD_DIRS=""
if [[ $OLD_COUNT -gt 50 ]]; then
  OLD_DIRS=$(echo "$ALL_OLD" | head -n $((OLD_COUNT - 50)))
fi
if [[ -n "$OLD_DIRS" ]]; then
  echo "$OLD_DIRS" | xargs rm -rf 2>/dev/null || true
  log_info "已清理 $(echo "$OLD_DIRS" | wc -l) 个旧目录"
fi

cd "$PROJECT_DIR"
if git checkout master 2>/dev/null; then
  log_info "已切换到 master 分支"
elif git checkout main 2>/dev/null; then
  log_info "已切换到 main 分支"
elif git checkout develop 2>/dev/null; then
  log_info "已切换到 develop 分支"
else
  log_warn "无法切换分支，保持当前分支"
fi

# ============================================================
# 输出结果
# ============================================================
log_info "=========================================="
log_info "收尾阶段完成"
log_info "=========================================="

[[ "$PASSED" == "true" ]] && PASSED_BOOL=true || PASSED_BOOL=false

jq -n \
  --argjson success true \
  --arg run_id "$RUN_ID" \
  --arg task_id "$TASK_ID" \
  --argjson passed $PASSED_BOOL \
  --argjson retry_count "$RETRY_COUNT" \
  --arg branch_name "$BRANCH_NAME" \
  --arg notion_status "$NEW_STATUS" \
  --arg report_file "$REPORT_FILE" \
  '{success: $success, run_id: $run_id, task_id: $task_id, passed: $passed, retry_count: $retry_count, branch_name: $branch_name, notion_status: $notion_status, report_file: $report_file}'
