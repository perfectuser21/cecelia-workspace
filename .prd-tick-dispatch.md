---
id: prd-tick-dispatch
version: 1.0.0
created: 2026-01-31
updated: 2026-01-31
changelog:
  - 1.0.0: 初始版本
---

# PRD - Tick Dispatch：接通自驱执行链路

## 背景

Brain 系统的零件已经齐全但没串起来：

| 零件 | 文件 | 状态 |
|------|------|------|
| Tick 心跳 | tick.js | ✅ 在跑，每 2 分钟 |
| 决策引擎 | decision.js | ⚠️ 只会 escalate/reprioritize，不会 dispatch |
| 执行器 | executor.js | ✅ triggerCeceliaRun() 完整可用 |
| PRD 队列 | prd-queue.js | ✅ 队列管理完整 |
| TRD 拆解 | decomposer.js | ✅ TRD→Milestone→PRD→Task |
| PRD 模板 | templates.js | ✅ 可生成 PRD |
| 意图识别 | intent.js | ✅ 自然语言→结构化 |
| 每日焦点 | focus.js | ✅ 选择当日最高优先级目标 |

**断裂点**：tick 的 `executeTick()` 只调 compareGoalProgress → generateDecision，而 decision 里没有 `dispatch` 类型的 action。executor.js 存在但没人调它。

## 目标

在 tick.js 的 executeTick() 中增加 **dispatch 阶段**，让 tick 能自动：
1. 从 queued 任务中选一个（P0 优先，按依赖顺序）
2. 检查并发槽位是否有空
3. 调 executor.triggerCeceliaRun() 启动执行
4. 更新任务状态为 in_progress
5. 执行完成后通过 execution-callback 回写状态

## 核心改动

### 1. tick.js — executeTick() 增加 dispatch 阶段

在现有的 decision engine 逻辑之后，增加：

```
Step 3: Task Dispatch（新增）
  a. 查询当前 in_progress 任务数（并发锁）
  b. 如果 < MAX_CONCURRENT（默认 1）
  c. 查询 queued 任务，按 priority + created_at 排序
  d. 跳过有未完成依赖的任务
  e. 检查 cecelia-run 是否可用
  f. 调 triggerCeceliaRun(task)
  g. 更新 task.status = 'in_progress'
  h. 记录 decision log
```

### 2. tick.js — 新增 dispatchNextTask() 函数

```javascript
async function dispatchNextTask() {
  // 1. 检查并发
  const runningCount = await getRunningTaskCount();
  if (runningCount >= MAX_CONCURRENT_TASKS) {
    return { dispatched: false, reason: 'max_concurrent_reached' };
  }

  // 2. 检查 cecelia-run 可用
  const available = await checkCeceliaRunAvailable();
  if (!available.available) {
    return { dispatched: false, reason: 'cecelia_run_unavailable' };
  }

  // 3. 选择任务（P0 > P1 > P2，跳过有依赖的）
  const task = await selectNextDispatchableTask();
  if (!task) {
    return { dispatched: false, reason: 'no_dispatchable_task' };
  }

  // 4. 执行
  const result = await triggerCeceliaRun(task);
  if (result.success) {
    await updateTaskStatus(task.id, 'in_progress');
  }

  return { dispatched: true, task_id: task.id, run_id: result.runId };
}
```

### 3. 任务选择逻辑 — selectNextDispatchableTask()

```sql
SELECT t.*
FROM tasks t
WHERE t.status = 'queued'
  AND t.priority IN ('P0', 'P1', 'P2')
  -- 跳过有未完成依赖的
  AND NOT EXISTS (
    SELECT 1 FROM jsonb_array_elements_text(t.payload->'depends_on') dep_id
    WHERE EXISTS (
      SELECT 1 FROM tasks dep
      WHERE dep.id::text = dep_id AND dep.status != 'completed'
    )
  )
ORDER BY
  CASE t.priority
    WHEN 'P0' THEN 0
    WHEN 'P1' THEN 1
    WHEN 'P2' THEN 2
  END,
  t.created_at ASC
LIMIT 1
```

### 4. execution-callback 回写增强

现有的 `/api/brain/execution-callback` 需要增加：
- 任务完成 → 更新 task.status = 'completed'
- 任务失败 → 更新 task.status = 'failed'
- 更新关联 KR 的进度（completed_tasks / total_tasks * 100）
- 更新关联 O 的进度（所有 KR 进度的加权平均）

### 5. 配置常量

```javascript
const MAX_CONCURRENT_TASKS = 1;    // 同时最多跑几个 cecelia-run
const DISPATCH_COOLDOWN_MS = 60000; // dispatch 后冷却 1 分钟（防止重复触发）
```

## 不做什么

- ❌ 不改 decision.js 的现有逻辑（escalate/reprioritize 保留）
- ❌ 不加 cron/定时任务（Phase 3 再做）
- ❌ 不加自然语言入口（Phase 4 再做）
- ❌ 不加 OKR→KR 自动拆解（Phase 2 再做）

## 成功标准

- [ ] tick 每 2 分钟执行时，如果有 queued P0/P1 任务且无 in_progress 任务，自动 dispatch
- [ ] dispatch 后 task 状态变为 in_progress
- [ ] cecelia-run 完成后通过 callback 更新 task 状态
- [ ] 完成后自动更新 KR 和 O 的进度百分比
- [ ] tick/status API 返回 last_dispatch 信息
- [ ] 并发限制生效（默认只跑 1 个）
- [ ] 有未完成依赖的任务不会被 dispatch

## 影响范围

| 文件 | 改动 |
|------|------|
| apps/core/src/brain/tick.js | 增加 dispatch 阶段 |
| apps/core/src/brain/routes.js | 增强 execution-callback |
| apps/core/src/brain/tick.d.ts | 更新类型声明 |
| 新增测试 | tick-dispatch.test.js |

## 风险

- executor.js 的 cecelia-run 调用是 fire-and-forget，如果进程崩溃没有 callback，任务会卡在 in_progress
  - **缓解**：tick 检查 in_progress 任务的 triggered_at，超过 30 分钟自动标记 failed
